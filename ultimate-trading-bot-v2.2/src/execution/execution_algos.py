"""
Execution Algorithms for Ultimate Trading Bot v2.2.

This module provides algorithmic execution strategies including
TWAP, VWAP, Implementation Shortfall, and Arrival Price algorithms.
"""

import asyncio
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable
from uuid import uuid4

import numpy as np
from pydantic import BaseModel, Field

from src.execution.base_executor import (
    BaseExecutor,
    Order,
    OrderSide,
    OrderType,
    TimeInForce,
    Fill,
    ExecutionResult,
)


logger = logging.getLogger(__name__)


class AlgoType(str, Enum):
    """Execution algorithm types."""

    TWAP = "twap"
    VWAP = "vwap"
    IMPLEMENTATION_SHORTFALL = "implementation_shortfall"
    ARRIVAL_PRICE = "arrival_price"
    POV = "pov"
    ICEBERG = "iceberg"
    SNIPER = "sniper"
    DARK = "dark"


class AlgoStatus(str, Enum):
    """Algorithm execution status."""

    PENDING = "pending"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    CANCELED = "canceled"
    ERROR = "error"


class AlgoConfig(BaseModel):
    """Base configuration for execution algorithms."""

    model_config = {"arbitrary_types_allowed": True}

    start_time: datetime | None = None
    end_time: datetime | None = None
    duration_minutes: int = Field(default=60, description="Execution duration in minutes")
    urgency: float = Field(default=0.5, ge=0, le=1, description="Execution urgency 0-1")
    min_fill_rate: float = Field(default=0.8, description="Minimum fill rate target")
    max_participation: float = Field(default=0.1, description="Max % of volume")
    price_limit: float | None = Field(default=None, description="Price limit")
    allow_extended_hours: bool = Field(default=False, description="Allow extended hours")


class TWAPConfig(AlgoConfig):
    """Configuration for TWAP algorithm."""

    num_slices: int = Field(default=10, description="Number of time slices")
    randomize_timing: bool = Field(default=True, description="Randomize slice timing")
    randomization_pct: float = Field(default=0.2, description="Timing randomization %")


class VWAPConfig(AlgoConfig):
    """Configuration for VWAP algorithm."""

    volume_profile: list[float] | None = Field(default=None, description="Historical volume profile")
    target_pov: float = Field(default=0.05, description="Target % of volume")
    track_vwap: bool = Field(default=True, description="Track VWAP benchmark")


class IcebergConfig(AlgoConfig):
    """Configuration for Iceberg algorithm."""

    display_size: float = Field(description="Visible order size")
    total_size: float = Field(description="Total order size")
    variance_pct: float = Field(default=0.1, description="Size variance %")
    replenish_threshold: float = Field(default=0.0, description="Replenish threshold")


class POVConfig(AlgoConfig):
    """Configuration for Percentage of Volume algorithm."""

    target_pov: float = Field(default=0.1, description="Target % of volume")
    min_pov: float = Field(default=0.05, description="Minimum % of volume")
    max_pov: float = Field(default=0.20, description="Maximum % of volume")


@dataclass
class AlgoOrder:
    """Order generated by execution algorithm."""

    order: Order
    slice_number: int
    target_time: datetime
    target_qty: float
    actual_qty: float = 0.0
    fill_price: float | None = None
    status: str = "pending"


@dataclass
class AlgoExecution:
    """Execution state for an algorithm."""

    algo_id: str
    algo_type: AlgoType
    symbol: str
    side: OrderSide
    total_qty: float
    status: AlgoStatus = AlgoStatus.PENDING

    start_time: datetime = field(default_factory=datetime.now)
    end_time: datetime | None = None

    filled_qty: float = 0.0
    avg_fill_price: float = 0.0
    arrival_price: float = 0.0

    slices: list[AlgoOrder] = field(default_factory=list)
    fills: list[Fill] = field(default_factory=list)

    slippage_bps: float = 0.0
    participation_rate: float = 0.0
    benchmark_diff: float = 0.0

    error_message: str | None = None


@dataclass
class AlgoMetrics:
    """Metrics for algorithm performance."""

    algo_type: AlgoType
    executions: int = 0
    avg_fill_rate: float = 0.0
    avg_slippage_bps: float = 0.0
    avg_duration_minutes: float = 0.0
    total_volume: float = 0.0


class BaseExecutionAlgo(ABC):
    """Base class for execution algorithms."""

    def __init__(
        self,
        executor: BaseExecutor,
        config: AlgoConfig,
    ):
        """
        Initialize execution algorithm.

        Args:
            executor: Order executor
            config: Algorithm configuration
        """
        self.executor = executor
        self.config = config
        self._execution: AlgoExecution | None = None
        self._running = False
        self._task: asyncio.Task | None = None

    @property
    @abstractmethod
    def algo_type(self) -> AlgoType:
        """Get algorithm type."""
        pass

    @abstractmethod
    async def _generate_schedule(
        self,
        symbol: str,
        side: OrderSide,
        total_qty: float,
        market_data: dict[str, Any],
    ) -> list[AlgoOrder]:
        """Generate execution schedule."""
        pass

    async def execute(
        self,
        symbol: str,
        side: OrderSide,
        quantity: float,
        market_data: dict[str, Any],
    ) -> AlgoExecution:
        """
        Execute the algorithm.

        Args:
            symbol: Asset symbol
            side: Order side
            quantity: Total quantity
            market_data: Current market data

        Returns:
            AlgoExecution result
        """
        self._execution = AlgoExecution(
            algo_id=str(uuid4()),
            algo_type=self.algo_type,
            symbol=symbol,
            side=side,
            total_qty=quantity,
            arrival_price=market_data.get("price", 0.0),
        )

        try:
            schedule = await self._generate_schedule(
                symbol, side, quantity, market_data
            )
            self._execution.slices = schedule
            self._execution.status = AlgoStatus.RUNNING
            self._running = True

            await self._execute_schedule()

            if self._execution.filled_qty >= quantity * self.config.min_fill_rate:
                self._execution.status = AlgoStatus.COMPLETED
            else:
                self._execution.status = AlgoStatus.ERROR
                self._execution.error_message = f"Fill rate {self._execution.filled_qty / quantity:.1%} below target"

        except Exception as e:
            self._execution.status = AlgoStatus.ERROR
            self._execution.error_message = str(e)
            logger.error(f"Algo execution error: {e}")

        finally:
            self._running = False
            self._execution.end_time = datetime.now()
            self._calculate_metrics()

        return self._execution

    async def _execute_schedule(self) -> None:
        """Execute the order schedule."""
        for algo_order in self._execution.slices:
            if not self._running:
                break

            now = datetime.now()
            if algo_order.target_time > now:
                wait_time = (algo_order.target_time - now).total_seconds()
                await asyncio.sleep(wait_time)

            if not self._running:
                break

            result = await self.executor.submit_order(algo_order.order)

            if result.success:
                algo_order.status = "filled" if algo_order.order.filled_qty > 0 else "submitted"
                algo_order.actual_qty = algo_order.order.filled_qty

                for fill in result.fills:
                    self._execution.fills.append(fill)
                    self._execution.filled_qty += fill.quantity

                    old_value = self._execution.avg_fill_price * (self._execution.filled_qty - fill.quantity)
                    new_value = old_value + fill.price * fill.quantity
                    self._execution.avg_fill_price = new_value / self._execution.filled_qty

            else:
                algo_order.status = "failed"
                logger.warning(f"Slice order failed: {result.error_message}")

    def _calculate_metrics(self) -> None:
        """Calculate execution metrics."""
        if self._execution.arrival_price > 0 and self._execution.avg_fill_price > 0:
            diff = self._execution.avg_fill_price - self._execution.arrival_price
            if self._execution.side == OrderSide.SELL:
                diff = -diff
            self._execution.slippage_bps = (diff / self._execution.arrival_price) * 10000

    async def cancel(self) -> None:
        """Cancel the algorithm execution."""
        self._running = False

        if self._execution:
            self._execution.status = AlgoStatus.CANCELED

        for algo_order in self._execution.slices if self._execution else []:
            if algo_order.status == "pending":
                try:
                    await self.executor.cancel_order(algo_order.order.order_id)
                except Exception:
                    pass

    async def pause(self) -> None:
        """Pause the algorithm execution."""
        self._running = False
        if self._execution:
            self._execution.status = AlgoStatus.PAUSED

    async def resume(self) -> None:
        """Resume the algorithm execution."""
        self._running = True
        if self._execution:
            self._execution.status = AlgoStatus.RUNNING


class TWAPAlgo(BaseExecutionAlgo):
    """Time-Weighted Average Price execution algorithm."""

    def __init__(
        self,
        executor: BaseExecutor,
        config: TWAPConfig | None = None,
    ):
        """
        Initialize TWAP algorithm.

        Args:
            executor: Order executor
            config: TWAP configuration
        """
        super().__init__(executor, config or TWAPConfig())
        self.twap_config: TWAPConfig = self.config  # type: ignore

    @property
    def algo_type(self) -> AlgoType:
        return AlgoType.TWAP

    async def _generate_schedule(
        self,
        symbol: str,
        side: OrderSide,
        total_qty: float,
        market_data: dict[str, Any],
    ) -> list[AlgoOrder]:
        """Generate TWAP schedule."""
        schedule: list[AlgoOrder] = []

        start = self.config.start_time or datetime.now()
        duration = timedelta(minutes=self.config.duration_minutes)
        end = self.config.end_time or (start + duration)

        total_seconds = (end - start).total_seconds()
        slice_interval = total_seconds / self.twap_config.num_slices
        slice_qty = total_qty / self.twap_config.num_slices

        for i in range(self.twap_config.num_slices):
            target_time = start + timedelta(seconds=slice_interval * i)

            if self.twap_config.randomize_timing:
                random_offset = np.random.uniform(
                    -slice_interval * self.twap_config.randomization_pct,
                    slice_interval * self.twap_config.randomization_pct,
                )
                target_time += timedelta(seconds=random_offset)
                target_time = max(start, min(end, target_time))

            order = Order(
                symbol=symbol,
                side=side,
                order_type=OrderType.MARKET,
                quantity=slice_qty,
                time_in_force=TimeInForce.IOC,
            )

            if self.config.price_limit:
                order.order_type = OrderType.LIMIT
                order.limit_price = self.config.price_limit

            algo_order = AlgoOrder(
                order=order,
                slice_number=i,
                target_time=target_time,
                target_qty=slice_qty,
            )
            schedule.append(algo_order)

        return schedule


class VWAPAlgo(BaseExecutionAlgo):
    """Volume-Weighted Average Price execution algorithm."""

    def __init__(
        self,
        executor: BaseExecutor,
        config: VWAPConfig | None = None,
    ):
        """
        Initialize VWAP algorithm.

        Args:
            executor: Order executor
            config: VWAP configuration
        """
        super().__init__(executor, config or VWAPConfig())
        self.vwap_config: VWAPConfig = self.config  # type: ignore

    @property
    def algo_type(self) -> AlgoType:
        return AlgoType.VWAP

    async def _generate_schedule(
        self,
        symbol: str,
        side: OrderSide,
        total_qty: float,
        market_data: dict[str, Any],
    ) -> list[AlgoOrder]:
        """Generate VWAP schedule."""
        schedule: list[AlgoOrder] = []

        start = self.config.start_time or datetime.now()
        duration = timedelta(minutes=self.config.duration_minutes)
        end = self.config.end_time or (start + duration)

        volume_profile = self.vwap_config.volume_profile
        if not volume_profile:
            volume_profile = self._get_default_profile(self.config.duration_minutes)

        profile_total = sum(volume_profile)
        normalized_profile = [v / profile_total for v in volume_profile]

        total_seconds = (end - start).total_seconds()
        interval = total_seconds / len(volume_profile)

        for i, weight in enumerate(normalized_profile):
            slice_qty = total_qty * weight
            target_time = start + timedelta(seconds=interval * i)

            order = Order(
                symbol=symbol,
                side=side,
                order_type=OrderType.MARKET,
                quantity=slice_qty,
                time_in_force=TimeInForce.IOC,
            )

            if self.config.price_limit:
                order.order_type = OrderType.LIMIT
                order.limit_price = self.config.price_limit

            algo_order = AlgoOrder(
                order=order,
                slice_number=i,
                target_time=target_time,
                target_qty=slice_qty,
            )
            schedule.append(algo_order)

        return schedule

    def _get_default_profile(self, duration_minutes: int) -> list[float]:
        """Get default volume profile (U-shaped for market hours)."""
        num_periods = max(10, duration_minutes // 6)

        profile = []
        for i in range(num_periods):
            x = i / (num_periods - 1)
            volume = 1.5 - 1.0 * (1 - (2 * x - 1) ** 2)
            profile.append(max(0.5, volume))

        return profile


class IcebergAlgo(BaseExecutionAlgo):
    """Iceberg execution algorithm."""

    def __init__(
        self,
        executor: BaseExecutor,
        config: IcebergConfig,
    ):
        """
        Initialize Iceberg algorithm.

        Args:
            executor: Order executor
            config: Iceberg configuration
        """
        super().__init__(executor, config)
        self.iceberg_config: IcebergConfig = config

    @property
    def algo_type(self) -> AlgoType:
        return AlgoType.ICEBERG

    async def _generate_schedule(
        self,
        symbol: str,
        side: OrderSide,
        total_qty: float,
        market_data: dict[str, Any],
    ) -> list[AlgoOrder]:
        """Generate Iceberg schedule."""
        schedule: list[AlgoOrder] = []

        remaining = total_qty
        slice_num = 0
        start = datetime.now()

        while remaining > 0:
            variance = self.iceberg_config.variance_pct
            size_factor = 1 + np.random.uniform(-variance, variance)
            slice_qty = min(self.iceberg_config.display_size * size_factor, remaining)

            order = Order(
                symbol=symbol,
                side=side,
                order_type=OrderType.LIMIT,
                quantity=slice_qty,
                limit_price=self.config.price_limit or market_data.get("price", 0),
                time_in_force=TimeInForce.GTC,
            )

            algo_order = AlgoOrder(
                order=order,
                slice_number=slice_num,
                target_time=start,
                target_qty=slice_qty,
            )
            schedule.append(algo_order)

            remaining -= slice_qty
            slice_num += 1

        return schedule


class POVAlgo(BaseExecutionAlgo):
    """Percentage of Volume execution algorithm."""

    def __init__(
        self,
        executor: BaseExecutor,
        config: POVConfig | None = None,
    ):
        """
        Initialize POV algorithm.

        Args:
            executor: Order executor
            config: POV configuration
        """
        super().__init__(executor, config or POVConfig())
        self.pov_config: POVConfig = self.config  # type: ignore

    @property
    def algo_type(self) -> AlgoType:
        return AlgoType.POV

    async def _generate_schedule(
        self,
        symbol: str,
        side: OrderSide,
        total_qty: float,
        market_data: dict[str, Any],
    ) -> list[AlgoOrder]:
        """Generate POV schedule (reactive, not pre-scheduled)."""
        order = Order(
            symbol=symbol,
            side=side,
            order_type=OrderType.MARKET,
            quantity=total_qty * self.pov_config.target_pov,
            time_in_force=TimeInForce.IOC,
        )

        algo_order = AlgoOrder(
            order=order,
            slice_number=0,
            target_time=datetime.now(),
            target_qty=total_qty,
        )

        return [algo_order]


class AlgoManager:
    """Manager for execution algorithms."""

    def __init__(self, executor: BaseExecutor):
        """
        Initialize algorithm manager.

        Args:
            executor: Order executor
        """
        self.executor = executor
        self._active_algos: dict[str, BaseExecutionAlgo] = {}
        self._executions: list[AlgoExecution] = []
        self._metrics: dict[AlgoType, AlgoMetrics] = {
            algo_type: AlgoMetrics(algo_type=algo_type) for algo_type in AlgoType
        }
        self._lock = asyncio.Lock()

        logger.info("AlgoManager initialized")

    async def execute_twap(
        self,
        symbol: str,
        side: OrderSide,
        quantity: float,
        config: TWAPConfig | None = None,
        market_data: dict[str, Any] | None = None,
    ) -> AlgoExecution:
        """Execute TWAP algorithm."""
        algo = TWAPAlgo(self.executor, config)
        return await self._execute_algo(algo, symbol, side, quantity, market_data or {})

    async def execute_vwap(
        self,
        symbol: str,
        side: OrderSide,
        quantity: float,
        config: VWAPConfig | None = None,
        market_data: dict[str, Any] | None = None,
    ) -> AlgoExecution:
        """Execute VWAP algorithm."""
        algo = VWAPAlgo(self.executor, config)
        return await self._execute_algo(algo, symbol, side, quantity, market_data or {})

    async def execute_iceberg(
        self,
        symbol: str,
        side: OrderSide,
        quantity: float,
        display_size: float,
        config: IcebergConfig | None = None,
        market_data: dict[str, Any] | None = None,
    ) -> AlgoExecution:
        """Execute Iceberg algorithm."""
        if config is None:
            config = IcebergConfig(display_size=display_size, total_size=quantity)
        algo = IcebergAlgo(self.executor, config)
        return await self._execute_algo(algo, symbol, side, quantity, market_data or {})

    async def execute_pov(
        self,
        symbol: str,
        side: OrderSide,
        quantity: float,
        config: POVConfig | None = None,
        market_data: dict[str, Any] | None = None,
    ) -> AlgoExecution:
        """Execute POV algorithm."""
        algo = POVAlgo(self.executor, config)
        return await self._execute_algo(algo, symbol, side, quantity, market_data or {})

    async def _execute_algo(
        self,
        algo: BaseExecutionAlgo,
        symbol: str,
        side: OrderSide,
        quantity: float,
        market_data: dict[str, Any],
    ) -> AlgoExecution:
        """Execute an algorithm."""
        execution = await algo.execute(symbol, side, quantity, market_data)

        async with self._lock:
            self._executions.append(execution)
            self._update_metrics(execution)

        return execution

    def _update_metrics(self, execution: AlgoExecution) -> None:
        """Update algorithm metrics."""
        metrics = self._metrics[execution.algo_type]
        metrics.executions += 1
        metrics.total_volume += execution.filled_qty * execution.avg_fill_price

        fill_rate = execution.filled_qty / execution.total_qty if execution.total_qty > 0 else 0
        metrics.avg_fill_rate = (
            (metrics.avg_fill_rate * (metrics.executions - 1) + fill_rate) / metrics.executions
        )

        metrics.avg_slippage_bps = (
            (metrics.avg_slippage_bps * (metrics.executions - 1) + execution.slippage_bps) /
            metrics.executions
        )

    async def cancel_algo(self, algo_id: str) -> bool:
        """Cancel an algorithm execution."""
        if algo_id in self._active_algos:
            await self._active_algos[algo_id].cancel()
            del self._active_algos[algo_id]
            return True
        return False

    def get_execution(self, algo_id: str) -> AlgoExecution | None:
        """Get execution by ID."""
        for execution in self._executions:
            if execution.algo_id == algo_id:
                return execution
        return None

    def get_executions(self, limit: int = 100) -> list[AlgoExecution]:
        """Get recent executions."""
        return self._executions[-limit:]

    def get_metrics(self, algo_type: AlgoType | None = None) -> dict[str, AlgoMetrics]:
        """Get algorithm metrics."""
        if algo_type:
            return {algo_type.value: self._metrics[algo_type]}
        return {t.value: m for t, m in self._metrics.items()}
